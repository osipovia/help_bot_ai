# Техническое видение проекта "LLM-ассистент для консультации клиентов"

**Версия:** 1.0  
**Дата:** 07.07.2025  
**Принцип:** KISS (Keep It Simple, Stupid) - максимальная простота для MVP

---

## 1. Технологии

### Backend
- **Python 3.11+** - основной язык разработки
- **aiogram** - современная библиотека для работы с Telegram Bot API
- **httpx** - HTTP-клиент для запросов к 1С API
- **sentence-transformers** - векторизация текста для RAG (локально)
- **chromadb** - встраиваемая векторная база данных (файловая)

### LLM
- **YandexGPT API** - внешний сервис для генерации ответов

### Управление проектом
- **uv** - современный менеджер пакетов и окружений Python
- **make** - автоматизация сборки, запуска и тестирования
- **pytest** - фреймворк для тестирования

### Конфигурация и данные
- **python-dotenv** - управление переменными окружения
- **pydantic-settings** - валидация конфигурации
- **dict/list** - хранение истории диалогов в памяти (простые структуры Python)

### Логгирование
- Встроенный **logging** Python - без внешних систем

### Деплой
- **Docker + docker-compose** - контейнеризация и оркестрация приложений
- **uv** - управление зависимостями и виртуальным окружением  
- **Git** - контроль версий документов и файлов

---

## 2. Принципы разработки

### Основные принципы
- **KISS (Keep It Simple)** - простота превыше всего
- **YAGNI (You Aren't Gonna Need It)** - не делаем то, что может понадобиться
- **Fail Fast** - быстро обнаруживаем и исправляем ошибки
- **Iterative Development** - небольшие итерации с рабочим результатом

### Практические подходы
- **Монолитная архитектура** - один процесс, простое развертывание
- **Прямолинейная логика** - минимум абстракций и паттернов
- **Минимальное тестирование** - тесты только для критичной бизнес-логики
- **Простое логгирование** - логи в stdout, без сложных систем
- **Ручной деплой** - пока без CI/CD

### Структура разработки
- **Один разработчик** - без сложных процессов ревью
- **Быстрые итерации** - цель: рабочий MVP за 1-2 недели
- **Документация по минимуму** - только критичные вещи

---

## 3. Структура проекта

```
help_bot_ai/
├── src/                          # Основной код приложения
│   ├── main.py                   # Точка входа приложения
│   ├── bot/                      # Логика telegram-бота
│   │   ├── handlers.py           # Обработчики сообщений
│   │   └── states.py             # Состояния диалога
│   ├── llm/                      # Работа с YandexGPT
│   │   └── client.py             # LLM клиент
│   ├── knowledge/                # База знаний и поиск
│   │   └── search.py             # Поиск по услугам
│   ├── payment/                  # Интеграция с 1С
│   │   └── client.py             # 1С API клиент
│   └── config/                   # Конфигурация
│       └── settings.py           # Настройки приложения
├── data/                         # Данные приложения
│   ├── knowledge/                # База знаний
│   │   └── services.json         # Услуги компании
│   └── chroma/                   # Векторная БД (создается автоматически)
├── tests/                        # Тесты
│   └── test_payment.py           # Тесты критичной логики
├── doc/                          # Документация
├── Dockerfile                    # Контейнеризация приложения
├── docker-compose.yml            # Оркестрация сервисов
├── Makefile                      # Автоматизация
├── pyproject.toml                # uv конфигурация
├── uv.lock                       # Блокировка зависимостей (создается автоматически)
├── .env.example                  # Пример переменных окружения
└── README.md                     # Описание проекта
```

**Принципы структуры:**
- Каждый модуль решает одну задачу
- Минимум файлов и уровней вложенности
- Понятные названия папок и файлов
- Разделение кода, данных и конфигурации
- **uv.lock** создается автоматически при `uv sync` (не редактировать вручную)

---

## 4. Архитектура проекта

### Высокоуровневая схема

```
[Пользователь] 
    ↕ Telegram API
[Telegram Bot] ← → [Dialog State (память)]
    ↓
[Message Handler]
    ↓
┌─────────────────┬─────────────────┐
│  Knowledge      │  LLM Client     │
│  Search         │  (YandexGPT)    │
│  (ChromaDB)     │                 │
└─────────────────┴─────────────────┘
    ↓
[Response Generator]
    ↓ (если нужна оплата)
[Payment Client (1C API)]
    ↓
[Final Response to User]
```

### Компоненты и их роли

1. **Telegram Bot (aiogram)** - получение/отправка сообщений
2. **Message Handler** - маршрутизация логики по типу запроса
3. **Knowledge Search** - поиск релевантной информации по услугам
4. **LLM Client** - генерация человекоподобных ответов
5. **Dialog State** - хранение контекста диалога в памяти (dict/list)
6. **Payment Client** - интеграция с 1С для создания платежных ссылок

### Принципы архитектуры

- **Монолит** - все компоненты в одном процессе
- **Синхронная обработка** - без очередей и async задач
- **Память как хранилище** - состояние диалогов в RAM
- **Прямые вызовы** - минимум абстракций между компонентами

---

## 5. Модель данных

### 1. Услуги компании (статические данные)

```python
# data/knowledge/services.json
{
  "services": [
    {
      "id": "course_fpv_flight_beginners",
      "name": "Обучение полетам и пилотированию FPV-дронов",
      "category": "Обучающие курсы и программы",
      "price": "32 000 ₽",
      "course_code": "FPV_BASE_01",  # Для 1С API
      "full_description": "..."
    }
  ]
}
```

### 2. Состояние диалогов (в памяти)

```python
# Простой dict для хранения сессий пользователей
user_sessions = {
    "user_id_123": {
        "messages": [
            {"role": "user", "content": "Привет"},
            {"role": "assistant", "content": "Здравствуйте!"}
        ],
        "state": "consultation",  # consultation, payment_request, etc.
        "selected_course": None,
        "phone": None,
        "created_at": "2025-01-07T10:00:00"
    }
}
```

### 3. Конфигурация приложения

```python
# src/config/settings.py (Pydantic)
class Settings(BaseSettings):
    telegram_bot_token: str
    yandex_gpt_api_key: str
    yandex_gpt_folder_id: str
    onec_api_url: str
    onec_client_id: str
    onec_client_secret: str
    log_level: str = "INFO"
```

### 4. Системный промпт (статические данные)

```python
# data/system_prompt.txt
"""
Ты консультант компании "Академия дронов". 
Твоя задача - помочь клиентам выбрать подходящие курсы и услуги.

Правила поведения:
- Будь дружелюбным и профессиональным
- Задавай уточняющие вопросы о потребностях клиента
- Предлагай наиболее подходящие услуги на основе предоставленной информации
- При готовности клиента к оплате, собери его контактные данные
- Отвечай только о наших услугах, не выходи за рамки темы
"""
```

### Принципы модели данных

- **Простые типы** - dict, list, str, int
- **JSON для статики** - услуги и конфигурация
- **Память для динамики** - состояние диалогов
- **Нет баз данных** - только файлы и RAM

---

## 6. Работа с LLM

### Интеграция с YandexGPT API

- **Модель:** `YandexGPT 5 Pro • RC` (мощная модель для качественных ответов)
- **Метод:** HTTP-запросы через httpx к Yandex Cloud API
- **Контекст:** Системный промпт + найденная информация об услугах + история диалога

### RAG (Retrieval-Augmented Generation) логика

1. **Поиск:** Пользовательский запрос → ChromaDB → топ-3 релевантных услуги
2. **Промпт:** Системный промпт + найденные услуги + история диалога
3. **Ответ:** YandexGPT генерирует ответ на основе предоставленной информации

### Структура промпта

```
СИСТЕМА: {содержимое_system_prompt.txt}

УСЛУГИ:
{найденные_услуги_из_базы_знаний}

ИСТОРИЯ ДИАЛОГА:
{последние_3-5_сообщений}

ПОЛЬЗОВАТЕЛЬ: {текущий_вопрос}
```

### Простые правила

- **Короткий промпт** - без сложных инструкций
- **Ограниченный контекст** - максимум 5 сообщений из истории
- **Без fine-tuning** - используем базовую модель
- **Фиксированная температура** - 0.7 для баланса креативности/точности

---

## 7. Мониторинг LLM

### Базовый мониторинг

- **Логгирование всех LLM запросов/ответов** в файлы
- **Счетчики в памяти:** количество запросов, ошибок, время ответа
- **Простые метрики:** успешность запросов, средняя длина ответов

### Структура логов LLM

```python
# Простой формат логов
{
    "timestamp": "2025-01-07T10:30:00",
    "user_id": "123456",
    "request_tokens": 150,
    "response_tokens": 80,
    "model": "yandexgpt-5-pro-rc",
    "success": true,
    "response_time_ms": 1200,
    "error": null
}
```

### Отслеживание проблем

- **Лимиты API** - логгируем ошибки 429 (Rate Limit)
- **Качество ответов** - ручная проверка логов (без автоматики)
- **Затраты** - простой подсчет токенов из логов

### Принципы мониторинга

- **Файловые логи** - без внешних систем мониторинга
- **Ручная аналитика** - просмотр логов глазами
- **Простые счетчики** - в памяти приложения
- **Без алертов** - пока не нужно

---

## 8. Сценарии работы

### Сценарий 1: Консультация по услугам
1. Пользователь задает вопрос об услугах
2. Бот ищет релевантную информацию в базе знаний (ChromaDB)
3. LLM генерирует ответ на основе найденной информации
4. Бот отправляет ответ пользователю
5. При необходимости задает уточняющие вопросы

### Сценарий 2: Оформление заказа и оплата
1. Пользователь выражает готовность записаться/оплатить
2. Бот уточняет выбранную услугу
3. Бот запрашивает контактные данные (ФИО, телефон)
4. Бот отправляет запрос в 1С API для создания заказа
5. Бот получает ссылку на оплату через СБП
6. Бот отправляет ссылку пользователю

### Сценарий 3: Передача менеджеру
1. **Автоматическая передача:** Бот не смог найти ответ или возникла ошибка
2. **По запросу клиента:** Пользователь просит связаться с человеком
3. Бот собирает контактные данные (ФИО, телефон)
4. Бот сообщает: "Передаю ваш запрос менеджеру, с вами свяжутся в течение рабочего дня"
5. Бот логгирует запрос для последующей обработки менеджером

### Сценарий 4: Обработка ошибок
1. При ошибке LLM API - отправляем заранее подготовленный ответ
2. При ошибке 1С API - просим связаться с менеджером
3. При некорректном вводе - переспрашиваем в дружелюбной форме

### Простые состояния диалога
- `consultation` - обычная консультация
- `payment_request` - сбор данных для оплаты
- `manager_request` - передача менеджеру
- `error` - обработка ошибок

### Принципы сценариев
- **Линейные потоки** - без сложных переходов между состояниями
- **Минимум состояний** - только критически необходимые
- **Fallback на человека** - при любых сложностях предлагаем связаться с менеджером
- **Всегда есть выход** - в любой момент можно попросить живого консультанта

---

## 9. Деплой

### Целевая среда
- **Docker + Docker Compose** - контейнеризация и оркестрация
- **Windows/macOS/Linux** - кроссплатформенный запуск
- **uv** - управление зависимостями внутри контейнера

### Процесс запуска
1. **Настройка переменных:** копирование `.env.example` → `.env`
2. **Сборка образа:** `make build` или `docker-compose build`
3. **Запуск:** `make run` или `docker-compose up -d`
4. **Проверка:** тестовое сообщение боту в Telegram

### Структура проекта для локального запуска
```bash
help_bot_ai/
├── src/                 # Код приложения
├── data/               # Данные (services.json, chroma/)
├── logs/               # Логи приложения (создается автоматически)
├── .env                # Локальная конфигурация
├── .env.example        # Пример настроек
├── pyproject.toml      # uv конфигурация
└── Makefile           # Команды управления
```

### Команды управления (Makefile)
```bash
make install    # uv sync - установка зависимостей
make run        # uv run python src/main.py - запуск бота
make test       # uv run pytest - запуск тестов
make clean      # Очистка временных файлов и кэша
```

### Мониторинг локальный
- **Логи:** вывод в консоль + файлы в logs/
- **Статус:** Ctrl+C для остановки
- **Перезапуск:** остановить и запустить заново

### Backup стратегия
- **Код:** Git репозиторий
- **Данные:** data/ в системе контроля версий
- **Конфигурация:** .env.example (без секретов)

### Принципы локального деплоя
- **Простой запуск** - одна команда для старта
- **Без контейнеров** - прямой запуск Python
- **Быстрая разработка** - мгновенный перезапуск
- **Минимум настроек** - только .env файл

---

## 10. Подход к конфигурированию

### Источники конфигурации
1. **Переменные окружения** (.env файл) - основной способ
2. **Значения по умолчанию** - в коде для необязательных параметров
3. **Валидация через Pydantic** - проверка на старте приложения

### Структура .env файла
```bash
# Telegram Bot
TELEGRAM_BOT_TOKEN=your_bot_token_here

# YandexGPT API
YANDEX_GPT_API_KEY=your_api_key
YANDEX_GPT_FOLDER_ID=your_folder_id

# 1C Integration
ONEC_API_URL=https://api.example.com/1c-integration
ONEC_CLIENT_ID=whatsapp_bot_prod_001
ONEC_CLIENT_SECRET=your_secret_key

# Application Settings
LOG_LEVEL=INFO
```

### Категории настроек
- **Обязательные** - API ключи, токены (ошибка при отсутствии)
- **Опциональные** - уровень логирования, таймауты (есть defaults)
- **Развертывание** - пути к файлам, порты (только для будущего)

### Безопасность конфигурации
- **.gitignore** - исключает .env из системы контроля версий
- **.env.example** - шаблон без реальных секретов (в Git)
- **Локальный .env** - только на рабочей машине (не в Git)

### .gitignore (обязательно)
```
# Environment files
.env
.env.local
.env.production

# UV virtual environment and cache
.venv/
.uv-cache/

# Logs
logs/
*.log

# Python
__pycache__/
*.pyc
*.pyo
.pytest_cache/

# ChromaDB
data/chroma/
```

### Принципы конфигурирования
- **Один .env файл** - все настройки в одном месте
- **Проверка на старте** - приложение не запустится без обязательных параметров
- **Нет nested конфигов** - плоская структура переменных
- **Понятные имена** - TELEGRAM_BOT_TOKEN вместо TBT
- **Защита секретов** - .env никогда не попадает в Git

---

## 11. Подход к логгированию

### Структура логов
- **Консоль** - для разработки и отладки
- **Файлы** - для сохранения истории
- **Ротация** - автоматическая по размеру (чтобы не забить диск)

### Уровни логирования
```python
DEBUG   # Детальная отладочная информация (только в разработке)
INFO    # Общая информация о работе бота
WARNING # Предупреждения (некритичные ошибки)
ERROR   # Ошибки, требующие внимания
```

### Что логгируем
- **Входящие сообщения** - user_id, текст запроса
- **LLM запросы/ответы** - для анализа качества
- **API 1С** - запросы на создание заказов, ошибки
- **Ошибки** - все исключения с трейсами
- **Системные события** - старт/остановка бота

### Формат логов
```
2025-01-07 10:30:15 INFO [user_123456] Received message: "Расскажите про курсы"
2025-01-07 10:30:16 INFO [llm] YandexGPT request tokens: 150, response tokens: 80
2025-01-07 10:30:17 ERROR [payment] 1C API error: Connection timeout
```

### Структура файлов логов
```
logs/
├── app.log              # Основные логи приложения
├── llm.log              # Детальные логи LLM взаимодействий
├── errors.log           # Только ошибки
└── archived/            # Старые логи (автоматическая ротация)
```

### Принципы логгирования
- **Простой формат** - понятный человеку
- **Файловая ротация** - по размеру 10MB → архив
- **Без внешних систем** - только локальные файлы
- **Структурированность** - user_id в каждой записи
- **Минимум шума** - логгируем только важное

---

**Техническое видение проекта готово. Принцип KISS соблюден - максимальная простота для быстрого MVP.** 